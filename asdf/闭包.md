1.执行上下文
执行环境定义了变量或函数有权访问的其他数据，并决定其各自的行为。每个执行环境都有一个对应的变量对象vo，
这个对象的作用就是保存在环境定义的变量和函数
2.全局执行环境
在js中window对象表示的是全局执行环境，全局执行环境是最外围的环境，所有的全局变量和函数都是作为window
对象的属性和方法的。这个执行环境在浏览器关闭时才进行销毁，也就是说window执行环境的生命周期贯穿整个浏览器显示。
3.局部执行环境
每个函数都有自己的执行环境，这些执行环境中所有代码执行完后，该环境呗销毁。js中程序是以流形式执行的，当执行流执行到一个函数的时候，这个函数的执行环境会被推送到一个环境栈中，在函数执行完毕后，栈中的这个执行环境会被弹出并把控制权交给之前调用函数的执行环境。
4.环境栈
js引擎在执行代码之前，首先会创建一个执行环境栈，然后创建全局环境并将其压入栈中作为栈底，再之后，随着执行流进入函数中，函数的执行上下文便会被推入执行环境栈中（即进入一个执行上下文），而在函数执行完毕后，执行环境便会把这个函数的环境弹出，并将控制权返回给之前的执行环境。
5.作用域
全局变量，局部变量，全局变量被理解为window对象的属性和方法，局部变量只能在相应的环境中使用。
es5没有会计作用域带来的问题
1.变量提升导致内层变量可能会覆盖外层变量
2.用来计数的循环变量泄露为全局变量
6.作用域链
一般情况下变量取值会到创建这个变量函数的作用于中取值，但是如果在当前作用于中没有查到值，就会向上级作用域去查，知道查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。
每个执行上下文都有3个重要属性：变量对象，作用域链，this。
7.垃圾回收
标记清除
工作原理：当变量进入环境时，将这个变量标记为进入环境，变量离开环境时，标记为离开环境，标记离开环境的就回收内存
1.GC标记所有的变量
2.方位所有变量的引用，并标记它们
3.标记所有引用链上的对象，已标记的对象不再被访问
4.最后删除所有未被标记的对象
引用计数
跟踪记录每个值被引用的次数
1.声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1
2.同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1
3.当包含这个引用类型的变量又被赋值成另一个值了，这个引用类型值的引用次数减1
4.当引用次数变成0，说明没办法访问这个值了
5.当垃圾收集器下一次运行时，它就会四方引用次数是0的值所占的内存。
内存泄露
1.全局变量的内存泄露
2.闭包引起的的内存泄漏
3.没有清理的DOM引用
4.被遗忘的定时器
5.相互引用